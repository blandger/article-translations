# Как я написал современную С++ библиотеку используя Rust

автор [Henri Sivonen](https://hsivonen.fi/author/), оригинальная статья [опубликована 2018-12-03](https://hsivonen.fi/modern-cpp-in-rust/)

Начиная с версии Firefox 56 получил новую версию библиотеку кодирования и конверации символов encoding_rs. Она написана на Rust и заменила старую C++ библиотеку uconv датированую 1999 годом. В начале все вызовы новой библиотеки конвертации были из C++ кода. Поэтому новая библиотека, не смотря на то что написана на Rust, нуждалась в адаптации при вызовах из C++ кода. На самом деле библиотека выглядит для вызывающего из C++ кода как современная C++ библиотека. Вот подходы, которые я использовал чтобы добиться этого.

Есть еще один [блог-пост на английском](https://hsivonen.fi/encoding_rs/) про саму библиотеку. Я представил материал данной статьи на докладе **RustFest Paris** ([видео](https://media.ccc.de/v/rustfest18-5-a_rust_crate_that_also_quacks_like_a_modern_c_library) , [слайды](https://hsivonen.fi/rustfest2018/)) 
 
 ## Современный C++ в каком смысле?
 
 “Современный” C++ в моем случае означает что интерфейс, который видят вызывающие из C++, соответствует [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) и использует новые определенные функции:
 
 * Выделение хип-памяти управляется возвращаемыми указателями на хип-объекты внутри std::unique_ptr / mozilla::UniquePtr.
 * Буферы памяти выделенные вызывающей стороной представлены используя gsl::span / mozilla::Span вместо обычных указателей и длины.
 * Возвращаемые значения представлены используя std::tuple / mozilla::Tuple вместо выходных "out" параметров.
 * Не нулевые (non-null) простые указатели аннотированы используя gsl::not_null / mozilla::NotNull.   
 
Упомянутые выше gsl:: это библиотека [Guidelines Support Library](https://github.com/microsoft/GSL), которая предоставляет функции, появление которых ожидается в Core Guidelines, но они еще не доступны в стандартной C++ библиотеке.

## C++ библиотека на Rust?

Написав библиотека C++ “на Rust” я говорю, что основная часть функционала написана на Rust, но интерфейсы предоставленные для вызова из C++ кода позволяют ей выглядеть, как будто она настоящая C++ библиотека.

## C++ и Rust совместимы через C Interop

C++ имеет достаточно сложный ABI ([Двоичный (бинарный) интерфейс приложений](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9)), ABI в Rust не стабилен и не документирован. Тем не менее для совместимости между C++ и Rust оба ЯП поддерживают функции, которые используют стабильный ABI языка Cи. Поэтому, создание совместимости между C++ и Rust включает написание некоторых вещей таким образом, что C++ "видит" Rust как Cи код, Rust "видит" C++ код тоже как Cи код.

## Упрощающие факторы

Данное описание не следует считать обстоятельным руководством по экспорту Rust кода на C++. Интерфейс к encoding_rs достаточно простой, в нем нет сложностей, которые можно ожидать в общем случае при взаимодействии между двумя языками. Тем не менее факторы, которые упрощают предоставление функций из encoding_rs в C++, можно использовать как небольшое руководство для упрощения необходимое в интересах более простой совместимости между языками при проектировании библиотек. Особенно обратите внимание на:

* encoding_rs никогда не вызывает C++, вызовы между языками однонаправленные
* encoding_rs не держит ссылки на объекты C++ после возврата из вызова, нет необходимости в Rust коде управлять памятью C++
* encoding_rs не представляет иерархию наследований ни в коде Rust ни в C++, отсутствуют vtables в обоих частях.
* Типы данных которыми манипулирует encoding_rs очень простые, последовательные буфферы и примитивы (buffers of u8/uint8_t и u16/char16_t). 
* Есть только поддержка конфигурации panic=abort (т.е. паника в Rust останавливает программу вместо разворачивания стэка) и представленный код является корректным если только использована данная опция. Представленный код не пытается предотвращать панику в Rust panics и разварачивать стэк вызова через FFI, т.к. это будет означать Undefined Behavior. ([Данное поведение было изменено](https://github.com/rust-lang/rust/pull/55982))

## Краткий обзор API



 
 